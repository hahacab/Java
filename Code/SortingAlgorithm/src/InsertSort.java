/*
插入排序 基本思想：每次将一个待排序的元素，按其关
键字的大小插入到前面已经排好序的子文件的适 当位置，直到全部记录插入完成为止。
 */
public class InsertSort {
    public static void main(String[] args) {

    }

    //直接插入排序
    public static void directInsertSort(int[] arr) {
/*
直接插入排序的效率分析 首先从空间来看，它只需要一个元素的辅助空间
，用于元素的位置交换。从时间分析，首先外层循 环要进行n-1次插入, 每次插入最少比较一次(正序), 移动0次;
最多比较i次(包括同监视哨R[0]的比较),移 动i＋1次(逆序)(i=2,3,…,n)。因此，直接插入排序的时间复杂度为O（n2）。
 直接插入算法的元素移动是顺序的，该方法是
稳定的。

直接插入排序的基本思想是：把n个待排序的元素 看成为一个有序表和一个无序表，开始时有序表中只包
含一个元素，无序表中包含有n-1个元素，排序过程中 每次从无序表中取出第一个元素，把它的排序码依次
与有序表元素的排序码进行比较，将它插入到有序表中的 适当位置，使之成为新的有序表
 */
        System.out.println("使用直接插入法进行排序");
        int arrLength = arr.length;
        for (int i = 1; i < arrLength; i++) {
            int tmp = arr[i];
            if (arr[i] < arr[i - 1]) {
                int j = i - 1;
                for (; j >= 0 && tmp < arr[j]; j--) {
                    arr[j + 1] = arr[j];
                }
                arr[j + 1] = tmp;
            }
        }
    }
    //希尔排序
    public static void shellSort(int[] arr) {
        /*
        希尔排序的基本思想：先将整个待排元
素序列分割成若干个子序列（由相隔某个“增 量”的元素组成的）分别进行直接插入排序， 待整个序列中的元素基本
有序（增量足够小） 时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接
近最好情况），效率是很高的，因此希尔排序 在时间效率上有较大提高。

1. 算法步骤
选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；
按增量序列个数 k，对序列进行 k 趟排序；
每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。
仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

虽然我们给出的算法是三层循环，最外层循环为
log2n数量级，中间的for循环是n数量级的，内循环远 远低于n数量级，因为当分组较多时，组内元素较少 ；
此循环次数少；当分组较少时，组内元素增多，但 已接近有序，循环次数并不增加。因此，希尔排序的 时间复杂性在
O（nlog2n）和O（n2 ）之间，大致为O （n1. 3）。
由于希尔排序对每个子序列单独比较，在比较时
进行元素移动，有可能改变相同排序码元素的原始顺 序，因此希尔排序是不稳定的。
         */
        System.out.println("使用希尔排序法进行排序");
        int arrLength = arr.length;
        int temp;
        //将序列差分为两段
        for (int step = arrLength /2; step >= 1; step/= 2) {
            for (int i = step; i < arrLength; i++) {
                temp = arr[i];
                int j = i - step;
                while (j >= 0 && arr[j] > temp) {
                    arr[j + step] = arr[j];
                    j -= step;
                }
                arr[j + step] = temp;
            }
        }
    }
}

